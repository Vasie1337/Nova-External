#include "../Public/exploits.h"
#include "../Public/offsets.h"

bool exploits::Tick()
{
    if (cfg::RapidFire && cache::CurrentWeapon && cache::WeaponData) {
        float LastFireTime = memory::ReadMemory<float>(cache::CurrentWeapon + 0x760);
        memory::WriteMemory<float>(cache::CurrentWeapon + 0x760, LastFireTime - 2.f);

        memory::WriteMemory<int>(cache::WeaponData + 0x9E0, 1);
    }

    if (cfg::NoRecoil && cache::PlayerController) {
        memory::WriteMemory<float>(cache::PlayerController + 0xC0, -1.f);
    }
    else {
        memory::WriteMemory<float>(cache::PlayerController + 0xC0, 1.f);
    }

    if (cfg::NoSpread && cache::CurrentWeapon) {
        memory::WriteMemory<float>(cache::CurrentWeapon + 0xC0, FLT_MAX);
    }
    else {
        memory::WriteMemory<float>(cache::CurrentWeapon + 0xC0, 0.0f);
    }

    if (cfg::ADSAir && cache::AcknowledgedPawn) {
        memory::WriteMemory<bool>(cache::AcknowledgedPawn + 0x24FD, true);
    }
    else {
        memory::WriteMemory<bool>(cache::AcknowledgedPawn + 0x24FD, false);
    }

    if (cfg::Spinbot && cache::Mesh) {
        static engine::vec3 orgin = { 0, 0, 0 };
        orgin.y += 20.f;
        memory::WriteMemory<engine::vec3>(cache::Mesh + offsets::RelativeRotation, orgin);
    }
    else {
        memory::WriteMemory<engine::vec3>(cache::Mesh + offsets::RelativeRotation, engine::vec3(0, -90, 0));
    }

    if (cfg::InstaRevive && cache::Mesh) {
        memory::WriteMemory<float>(cache::AcknowledgedPawn + 0x2178, 1.f);
    }
    else {
        memory::WriteMemory<float>(cache::AcknowledgedPawn + 0x2178, 0.f);
    }

    if (cfg::Airstuck && cache::Mesh)
    {
        if (GetAsyncKeyState(VK_SHIFT)) {
            memory::WriteMemory<float>(cache::AcknowledgedPawn + 0xC0, 0.f);
        }
        else {
            memory::WriteMemory<float>(cache::AcknowledgedPawn + 0xC0, 1.f);
        }
    }

    if (cfg::ChangeWeaponMesh && cache::WeaponMesh)
    {
        memory::WriteMemory<engine::vec3>(cache::WeaponMesh + 0x17C, { cfg::WeaponMeshScale, cfg::WeaponMeshScale, cfg::WeaponMeshScale });
    }
    else {
        memory::WriteMemory<engine::vec3>(cache::WeaponMesh + 0x17C, { 1.f,1.f,1.f });
    }

    if (cfg::ChangePlayerMesh && cache::Mesh)
    {
        memory::WriteMemory<engine::vec3>(cache::Mesh + 0x17C, { cfg::PlayerMeshScale, cfg::PlayerMeshScale, cfg::PlayerMeshScale });
    }
    else {
        memory::WriteMemory<engine::vec3>(cache::Mesh + 0x17C, { 1.f,1.f,1.f });
    }
    return true;
}
